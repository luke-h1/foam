name: Deploy production (OTA or build)

on:
  workflow_dispatch:
jobs:
  determine_and_deploy:
    runs-on: foam
    timeout-minutes: 40
    concurrency: main-deploy-${{ github.run_id }}
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: üîé Check for EXPO_TOKEN
        run: |
          if [ -z "${{ secrets.EXPO_TOKEN }}" ]; then
            echo "You must provide an EXPO_TOKEN secret linked to this project's Expo account in this repo's secrets. Learn more: https://docs.expo.dev/tutorial/eas/using-github/"
            exit 1
          fi

      - name: üèó Setup repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: main
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Load secrets
        id: load_secrets
        uses: 1password/load-secrets-action@v3
        with:
          export-env: true
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}
          TWITCH_CLIENT_ID: op://ci-cd/foam-staging/TWITCH_CLIENT_ID
          TWITCH_CLIENT_SECRET: op://ci-cd/foam-staging/TWITCH_CLIENT_SECRET
          AUTH_PROXY_API_BASE_URL: op://ci-cd/foam-staging/AUTH_PROXY_API_BASE_URL
          AUTH_PROXY_API_KEY: op://ci-cd/foam-staging/AUTH_PROXY_API_KEY
          SENTRY_AUTH_TOKEN: op://ci-cd/foam-staging/SENTRY_AUTH_TOKEN
          GOOGLE_SERVICES_IOS_PROD_BS4: op://ci-cd/foam-staging/GOOGLE_SERVICES_IOS_PROD_BS4
          GOOGLE_SERVICES_ANDROID_PROD_BS4: op://ci-cd/foam-staging/GOOGLE_SERVICES_ANDROID_PROD_BS4
          SLACK_WEBHOOK_URL: op://ci-cd/foam-staging/SLACK_WEBHOOK_URL
          OP_ENV_FILE: ".env"

      - name: üìÑ Decode and write Google service files
        run: |
          if [ -z "$GOOGLE_SERVICES_ANDROID_PROD_BS4" ]; then
            echo "Error: GOOGLE_SERVICES_ANDROID_PROD_BS4 is not set"
            exit 1
          fi
          if [ -z "$GOOGLE_SERVICES_IOS_PROD_BS4" ]; then
            echo "Error: GOOGLE_SERVICES_IOS_PROD_BS4 is not set"
            exit 1
          fi
          
          echo "Decoding Android Google Services JSON..."
          echo "$GOOGLE_SERVICES_ANDROID_PROD_BS4" | base64 -d > google-services-prod.json
          
          echo "Decoding iOS Google Services plist..."
          echo "$GOOGLE_SERVICES_IOS_PROD_BS4" | base64 -d > GoogleService-Info-prod.plist
          
          echo "‚úÖ Google service files written successfully"

      - name: ü•ü Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: '.bun-version'

      - name: Setup Node
        uses: actions/setup-node@v4.1.0
        with:
          node-version-file: .nvmrc

      - name: üì¶ Install dependencies
        run: bun install --frozen-lockfile

      - name: Œõ Setup EAS
        uses: expo/expo-github-action@v8
        with:
          eas-version: latest
          token: ${{ secrets.EXPO_TOKEN }}
          packager: bun
          patch-watchers: false

      - name: üîç Check if build is needed (fingerprint check)
        id: fingerprint_check
        uses: expo/expo-github-action/continuous-deploy-fingerprint-info@main
        with:
          profile: production
          branch: production

      - name: üìä Debug fingerprint check outputs
        run: |
          echo "=== Fingerprint Check Results ==="
          echo "build-needed: ${{ steps.fingerprint_check.outputs.build-needed }}"
          echo "ios-build-exists: ${{ steps.fingerprint_check.outputs.ios-build-exists }}"
          echo "android-build-exists: ${{ steps.fingerprint_check.outputs.android-build-exists }}"
          echo "ios-fingerprint: ${{ steps.fingerprint_check.outputs.ios-fingerprint }}"
          echo "android-fingerprint: ${{ steps.fingerprint_check.outputs.android-fingerprint }}"
          echo "=================================="

      - name: üîß Normalize build-needed value
        id: normalize_build_needed
        run: |
          IOS_FINGERPRINT="${{ steps.fingerprint_check.outputs.ios-fingerprint }}"
          if [ -z "$IOS_FINGERPRINT" ]; then
            echo "iOS fingerprint is blank, build needed"
            echo "build-needed=true" >> $GITHUB_OUTPUT
          else
            echo "iOS fingerprint exists: $IOS_FINGERPRINT, no build needed"
            echo "build-needed=false" >> $GITHUB_OUTPUT
          fi

      - name: üìù Bump version in app.config.ts
        if: steps.normalize_build_needed.outputs.build-needed == 'true'
        run: |
          # Read current version using sed (more portable than grep -oP)
          CURRENT_VERSION=$(sed -n "s/.*const VERSION = '\\([^']*\\)'.*/\\1/p" app.config.ts)
          echo "Current version: $CURRENT_VERSION"
          
          # Parse version parts (assuming semver format like 0.0.36)
          IFS='.' read -r -a VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_PARTS[0]}
          MINOR=${VERSION_PARTS[1]}
          PATCH=${VERSION_PARTS[2]}
          
          # Increment patch version
          NEW_PATCH=$((PATCH + 1))
          NEW_VERSION="$MAJOR.$MINOR.$NEW_PATCH"
          echo "New version: $NEW_VERSION"

          sed -i.bak "s/const VERSION = '$CURRENT_VERSION'/const VERSION = '$NEW_VERSION'/" app.config.ts
          rm -f app.config.ts.bak

          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV
          echo "VERSION_BUMPED=true" >> $GITHUB_ENV

      - name: üíæ Commit version bump
        if: steps.normalize_build_needed.outputs.build-needed == 'true' && env.VERSION_BUMPED == 'true'
        run: |
          git config --global user.name 'luke-h1'
          git config --global user.email 'luke-h1@users.noreply.github.com'
          
          # Check if there are actual changes to commit
          git add app.config.ts
          if git diff --staged --quiet; then
            echo "No changes to commit in app.config.ts"
            exit 0
          fi
          
          # Commit the changes
          git commit -m "chore(release): bump version to ${{ env.NEW_VERSION }} [skip ci]"
          
          # Push to main branch
          git push origin main
          
          echo "‚úÖ Successfully pushed version bump to GitHub"

      - name: üè∑Ô∏è Check if tag exists
        if: steps.normalize_build_needed.outputs.build-needed == 'true' && env.VERSION_BUMPED == 'true'
        id: check_tag
        run: |
          TAG_NAME="v${{ env.NEW_VERSION }}"
          if git ls-remote --tags origin "$TAG_NAME" | grep -q "$TAG_NAME"; then
            echo "tag-exists=true" >> $GITHUB_OUTPUT
            echo "Tag $TAG_NAME already exists"
          else
            echo "tag-exists=false" >> $GITHUB_OUTPUT
            echo "Tag $TAG_NAME does not exist"
          fi
          echo "TAG_NAME=$TAG_NAME" >> $GITHUB_ENV

      - name: üè∑Ô∏è Create GitHub tag
        if: steps.normalize_build_needed.outputs.build-needed == 'true' && env.VERSION_BUMPED == 'true' && steps.check_tag.outputs.tag-exists == 'false'
        run: |
          git tag -a "v${{ env.NEW_VERSION }}" -m "v${{ env.NEW_VERSION }}"
          git push origin "v${{ env.NEW_VERSION }}"
          echo "‚úÖ Created tag v${{ env.NEW_VERSION }}"

      - name: üì¶ Check if release exists
        if: steps.normalize_build_needed.outputs.build-needed == 'true' && env.VERSION_BUMPED == 'true'
        id: check_release
        run: |
          TAG_NAME="v${{ env.NEW_VERSION }}"
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/$TAG_NAME")
          
          if [ "$RESPONSE" = "200" ]; then
            echo "release-exists=true" >> $GITHUB_OUTPUT
            echo "Release $TAG_NAME already exists"
          else
            echo "release-exists=false" >> $GITHUB_OUTPUT
            echo "Release $TAG_NAME does not exist (HTTP $RESPONSE)"
          fi

      - name: üì¶ Create GitHub release
        if: steps.normalize_build_needed.outputs.build-needed == 'true' && env.VERSION_BUMPED == 'true' && steps.check_release.outputs.release-exists == 'false'
        run: |
          TAG_NAME="v${{ env.NEW_VERSION }}"
          curl -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Content-Type: application/json" \
            "https://api.github.com/repos/${{ github.repository }}/releases" \
            -d "{
              \"tag_name\": \"$TAG_NAME\",
              \"name\": \"Release $TAG_NAME\",
              \"body\": \"Production release $TAG_NAME\",
              \"target_commitish\": \"main\",
              \"draft\": false,
              \"prerelease\": false
            }"
          echo "‚úÖ Created release $TAG_NAME"

      - name: üìñ Get current version for OTA
        if: steps.normalize_build_needed.outputs.build-needed == 'false'
        id: get_ota_version
        run: |
          CURRENT_VERSION=$(sed -n "s/.*const VERSION = '\\([^']*\\)'.*/\\1/p" app.config.ts)
          echo "CURRENT_VERSION=$CURRENT_VERSION" >> $GITHUB_ENV
          echo "Current version for OTA: $CURRENT_VERSION"

      - name: üöÄ Create OTA update
        if: steps.normalize_build_needed.outputs.build-needed == 'false'
        id: ota_update
        run: |
          OUTPUT=$(bun eas update --channel production --environment production --message "release OTA" --non-interactive --clear-cache 2>&1)
          echo "$OUTPUT"
          echo "ota-output<<EOF" >> $GITHUB_OUTPUT
          echo "$OUTPUT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Extract Update group ID as fingerprint
          UPDATE_GROUP_ID=$(echo "$OUTPUT" | grep -i "Update group ID" | sed 's/.*Update group ID[[:space:]]*//' | xargs)
          if [ -n "$UPDATE_GROUP_ID" ]; then
            echo "ota-fingerprint=$UPDATE_GROUP_ID" >> $GITHUB_OUTPUT
            echo "Extracted OTA fingerprint: $UPDATE_GROUP_ID"
          else
            # Fallback: try to extract from error message or use first available ID
            UPDATE_GROUP_ID=$(echo "$OUTPUT" | grep -i "update.*id" | head -n 1 | sed 's/.*[Ii][Dd][[:space:]]*//' | xargs)
            if [ -n "$UPDATE_GROUP_ID" ]; then
              echo "ota-fingerprint=$UPDATE_GROUP_ID" >> $GITHUB_OUTPUT
              echo "Extracted OTA fingerprint (fallback): $UPDATE_GROUP_ID"
            else
              echo "ota-fingerprint=unknown" >> $GITHUB_OUTPUT
              echo "Warning: Could not extract OTA fingerprint"
            fi
          fi
          
          # Check for fingerprint errors
          if echo "$OUTPUT" | grep -q "No compatible builds found for the following fingerprints:"; then
            echo "fingerprint-error=true" >> $GITHUB_OUTPUT
          else
            echo "fingerprint-error=false" >> $GITHUB_OUTPUT
          fi

      - name: üè∑Ô∏è Create OTA tag
        if: steps.normalize_build_needed.outputs.build-needed == 'false'
        run: |
          git config --global user.name 'luke-h1'
          git config --global user.email 'luke-h1@users.noreply.github.com'
          
          # Create tag name in format: {VERSION}-{FINGERPRINT}
          OTA_FINGERPRINT="${{ steps.ota_update.outputs.ota-fingerprint }}"
          TAG_NAME="${{ env.CURRENT_VERSION }}-${OTA_FINGERPRINT}"
          
          # Create tag with OTA output as message
          OTA_OUTPUT="${{ steps.ota_update.outputs.ota-output }}"
          TAG_MESSAGE=$(printf "OTA Update %s\n\n%s" "${{ env.CURRENT_VERSION }}" "$OTA_OUTPUT")
          git tag -a "$TAG_NAME" -m "$TAG_MESSAGE"
          
          # Push tag
          git push origin "$TAG_NAME"
          echo "‚úÖ Created OTA tag $TAG_NAME"

      - name: üì¢ Send OTA update to Slack
        if: steps.normalize_build_needed.outputs.build-needed == 'false' && env.SLACK_WEBHOOK_URL != ''
        run: |
          if [ -z "$SLACK_WEBHOOK_URL" ]; then
            echo "SLACK_WEBHOOK_URL not set, skipping Slack notification"
            exit 0
          fi
          
          OTA_OUTPUT="${{ steps.ota_update.outputs.ota-output }}"
          
          # Escape JSON special characters: backslash, quotes, newlines, tabs
          ESCAPED_OUTPUT=$(echo "$OTA_OUTPUT" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g' | sed 's/\t/\\t/g')
          
          # Create Slack message payload
          PAYLOAD=$(cat <<JSON
          {
            "text": "üöÄ Production OTA Update Published",
            "blocks": [
              {
                "type": "header",
                "text": {
                  "type": "plain_text",
                  "text": "üöÄ Production OTA Update Published"
                }
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Version:* ${{ env.CURRENT_VERSION }}\n*Branch:* production\n\n\`\`\`${ESCAPED_OUTPUT}\`\`\`"
                }
              }
            ]
          }
          JSON
          )
          
          curl -X POST -H 'Content-type: application/json' \
            --data "$PAYLOAD" \
            "$SLACK_WEBHOOK_URL"

      - name: ‚ö†Ô∏è Send fingerprint warning to Slack
        if: steps.normalize_build_needed.outputs.build-needed == 'false' && steps.ota_update.outputs.fingerprint-error == 'true' && env.SLACK_WEBHOOK_URL != ''
        run: |
          if [ -z "$SLACK_WEBHOOK_URL" ]; then
            echo "SLACK_WEBHOOK_URL not set, skipping Slack notification"
            exit 0
          fi
          
          # Extract fingerprint information from output
          OTA_OUTPUT="${{ steps.ota_update.outputs.ota-output }}"
          
          # Extract iOS and Android fingerprints and URLs
          IOS_FINGERPRINT=$(echo "$OTA_OUTPUT" | grep -A 1 "iOS fingerprint:" | tail -n 1 | xargs)
          IOS_URL=$(echo "$OTA_OUTPUT" | grep -A 2 "iOS fingerprint:" | grep "URL" | sed 's/.*URL.*: *//' | xargs)
          ANDROID_FINGERPRINT=$(echo "$OTA_OUTPUT" | grep -A 1 "Android fingerprint:" | tail -n 1 | xargs)
          ANDROID_URL=$(echo "$OTA_OUTPUT" | grep -A 2 "Android fingerprint:" | grep "URL" | sed 's/.*URL.*: *//' | xargs)
          
          # Escape JSON special characters for URLs
          ESCAPED_IOS_URL=$(echo "$IOS_URL" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g')
          ESCAPED_ANDROID_URL=$(echo "$ANDROID_URL" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g')
          
          # Create Slack warning message payload
          PAYLOAD=$(cat <<JSON
          {
            "text": "‚ö†Ô∏è Warning: No compatible builds found for fingerprints",
            "blocks": [
              {
                "type": "header",
                "text": {
                  "type": "plain_text",
                  "text": "‚ö†Ô∏è Warning: No Compatible Builds Found"
                }
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Version:* ${{ env.CURRENT_VERSION }}\n*Branch:* production\n\n*No compatible builds found for the following fingerprints:*"
                }
              },
              {
                "type": "section",
                "fields": [
                  {
                    "type": "mrkdwn",
                    "text": "*iOS Fingerprint:*\n\`${IOS_FINGERPRINT}\`"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Android Fingerprint:*\n\`${ANDROID_FINGERPRINT}\`"
                  }
                ]
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*iOS URL:* <${ESCAPED_IOS_URL}|View fingerprint>\n*Android URL:* <${ESCAPED_ANDROID_URL}|View fingerprint>"
                }
              }
            ]
          }
          JSON
          )
          
          curl -X POST -H 'Content-type: application/json' \
            --data "$PAYLOAD" \
            "$SLACK_WEBHOOK_URL"

      - name: üèóÔ∏è Trigger build
        if: steps.normalize_build_needed.outputs.build-needed == 'true'
        run: |
          EXPO_PUBLIC_ENABLE_TREESHACKING=1 EXPO_APPLE_TEAM_ID="XJA7HDCMMY" bun eas build --profile production --platform ios --non-interactive --no-wait --local --output ./app-production.abd

      - name: Submit build
        if: steps.normalize_build_needed.outputs.build-needed == 'true'
        run: | 
          bun run eas submit -p ios --path ./app-production.abd
