name: Deploy production (OTA or build)

on:
  workflow_dispatch:
jobs:
  determine_and_deploy:
    runs-on: foam
    timeout-minutes: 40
    concurrency: main-deploy-${{ github.run_id }}
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: üîé Check for EXPO_TOKEN
        run: |
          if [ -z "${{ secrets.EXPO_TOKEN }}" ]; then
            echo "You must provide an EXPO_TOKEN secret linked to this project's Expo account in this repo's secrets. Learn more: https://docs.expo.dev/tutorial/eas/using-github/"
            exit 1
          fi

      - name: üèó Setup repo
        uses: actions/checkout@v4
        with:
          ref: main
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ü•ü Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version-file: '.bun-version'

      - name: Load secrets
        id: load_secrets
        uses: 1password/load-secrets-action@v3
        with:
          export-env: true
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}
          TWITCH_CLIENT_ID: op://ci-cd/foam-staging/TWITCH_CLIENT_ID
          TWITCH_CLIENT_SECRET: op://ci-cd/foam-staging/TWITCH_CLIENT_SECRET
          AUTH_PROXY_API_BASE_URL: op://ci-cd/foam-staging/AUTH_PROXY_API_BASE_URL
          AUTH_PROXY_API_KEY: op://ci-cd/foam-staging/AUTH_PROXY_API_KEY
          SENTRY_AUTH_TOKEN: op://ci-cd/foam-staging/SENTRY_AUTH_TOKEN
          GOOGLE_SERVICES_IOS_PROD_BS4: op://ci-cd/foam-staging/GOOGLE_SERVICES_IOS_PROD_BS4
          GOOGLE_SERVICES_ANDROID_PROD_BS4: op://ci-cd/foam-staging/GOOGLE_SERVICES_ANDROID_PROD_BS4
          SLACK_WEBHOOK_URL: op://ci-cd/foam-staging/SLACK_WEBHOOK_URL
          OP_ENV_FILE: ".env"

      - name: üìÑ Decode and write Google service files
        run: |
          if [ -z "$GOOGLE_SERVICES_ANDROID_PROD_BS4" ]; then
            echo "Error: GOOGLE_SERVICES_ANDROID_PROD_BS4 is not set"
            exit 1
          fi
          if [ -z "$GOOGLE_SERVICES_IOS_PROD_BS4" ]; then
            echo "Error: GOOGLE_SERVICES_IOS_PROD_BS4 is not set"
            exit 1
          fi
          
          echo "Decoding Android Google Services JSON..."
          echo "$GOOGLE_SERVICES_ANDROID_PROD_BS4" | base64 -d > google-services-prod.json
          
          echo "Decoding iOS Google Services plist..."
          echo "$GOOGLE_SERVICES_IOS_PROD_BS4" | base64 -d > GoogleService-Info-prod.plist
          
          echo "‚úÖ Google service files written successfully"

      - name: Setup Node
        uses: actions/setup-node@v4.1.0
        with:
          node-version-file: .nvmrc

      - name: üì¶ Install dependencies
        run: bun install --frozen-lockfile

      - name: Œõ Setup EAS
        uses: expo/expo-github-action@v8
        with:
          eas-version: latest
          token: ${{ secrets.EXPO_TOKEN }}
          packager: bun
          patch-watchers: false

      - name: üìñ Get current version
        id: get_current_version
        run: |
          CURRENT_VERSION=$(sed -n "s/.*const VERSION = '\\([^']*\\)'.*/\\1/p" app.config.ts)
          echo "CURRENT_VERSION=$CURRENT_VERSION" >> $GITHUB_ENV
          echo "current-version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version in app.config.ts: $CURRENT_VERSION"

      - name: üè∑Ô∏è Get last built version from tags
        id: get_last_built_version
        run: |
          # Get the latest version tag (check both formats: 0.0.36 and v0.0.36)
          # First try without 'v' prefix, then with 'v' prefix for backward compatibility
          LAST_TAG=$(git tag -l "*.*.*" | grep -E "^(v)?[0-9]+\.[0-9]+\.[0-9]+$" | sed 's/^v//' | sort -V | tail -n 1)
          if [ -z "$LAST_TAG" ]; then
            echo "No version tags found, assuming first build"
            echo "last-built-version=" >> $GITHUB_OUTPUT
            echo "version-changed=true" >> $GITHUB_OUTPUT
          else
            # Use tag directly as version (no 'v' prefix)
            LAST_VERSION="$LAST_TAG"
            echo "last-built-version=$LAST_VERSION" >> $GITHUB_OUTPUT
            echo "Last built version from tag: $LAST_VERSION"
            
            # Compare versions using semantic versioning
            CURRENT_VERSION="${{ steps.get_current_version.outputs.current-version }}"
            
            # Use sort -V for version comparison (works for semver)
            # If current version sorts after last version, it's newer
            HIGHER_VERSION=$(printf "%s\n%s" "$LAST_VERSION" "$CURRENT_VERSION" | sort -V | tail -n 1)
            
            if [ "$CURRENT_VERSION" != "$LAST_VERSION" ]; then
              if [ "$HIGHER_VERSION" = "$CURRENT_VERSION" ]; then
                echo "Version increased: $LAST_VERSION -> $CURRENT_VERSION (build needed)"
                echo "version-changed=true" >> $GITHUB_OUTPUT
              else
                echo "Version decreased: $LAST_VERSION -> $CURRENT_VERSION (unexpected, but build needed)"
                echo "version-changed=true" >> $GITHUB_OUTPUT
              fi
            else
              echo "Version unchanged: $CURRENT_VERSION"
              echo "version-changed=false" >> $GITHUB_OUTPUT
            fi
          fi

      - name: üîç Check if build is needed (fingerprint check)
        id: fingerprint_check
        uses: expo/expo-github-action/continuous-deploy-fingerprint-info@main
        with:
          profile: production
          branch: production

      - name: üìä Debug fingerprint check outputs
        run: |
          echo "=== Fingerprint Check Results ==="
          echo "build-needed: ${{ steps.fingerprint_check.outputs.build-needed }}"
          echo "ios-build-exists: ${{ steps.fingerprint_check.outputs.ios-build-exists }}"
          echo "android-build-exists: ${{ steps.fingerprint_check.outputs.android-build-exists }}"
          echo "ios-fingerprint: ${{ steps.fingerprint_check.outputs.ios-fingerprint }}"
          echo "android-fingerprint: ${{ steps.fingerprint_check.outputs.android-fingerprint }}"
          echo "version-changed: ${{ steps.get_last_built_version.outputs.version-changed }}"
          echo "current-version: ${{ steps.get_current_version.outputs.current-version }}"
          echo "last-built-version: ${{ steps.get_last_built_version.outputs.last-built-version }}"
          echo "=================================="

      - name: üîß Normalize build-needed value
        id: normalize_build_needed
        run: |
          IOS_FINGERPRINT="${{ steps.fingerprint_check.outputs.ios-fingerprint }}"
          VERSION_CHANGED="${{ steps.get_last_built_version.outputs.version-changed }}"
          
          # Build needed if:
          # 1. Version has changed (new version requires new build)
          # 2. OR fingerprint doesn't exist (no build for current fingerprint)
          if [ "$VERSION_CHANGED" = "true" ]; then
            echo "Version changed, build needed"
            echo "build-needed=true" >> $GITHUB_OUTPUT
            echo "build-reason=version-changed" >> $GITHUB_OUTPUT
          elif [ -z "$IOS_FINGERPRINT" ]; then
            echo "iOS fingerprint is blank, build needed"
            echo "build-needed=true" >> $GITHUB_OUTPUT
            echo "build-reason=no-fingerprint" >> $GITHUB_OUTPUT
          else
            echo "iOS fingerprint exists: $IOS_FINGERPRINT, version unchanged, no build needed"
            echo "build-needed=false" >> $GITHUB_OUTPUT
            echo "build-reason=none" >> $GITHUB_OUTPUT
          fi

      - name: üìù Bump version in app.config.ts
        if: steps.normalize_build_needed.outputs.build-needed == 'true'
        run: |
          # Read current version using sed (more portable than grep -oP)
          CURRENT_VERSION=$(sed -n "s/.*const VERSION = '\\([^']*\\)'.*/\\1/p" app.config.ts)
          echo "Current version: $CURRENT_VERSION"
          
          # Parse version parts (assuming semver format like 0.0.36)
          IFS='.' read -r -a VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_PARTS[0]}
          MINOR=${VERSION_PARTS[1]}
          PATCH=${VERSION_PARTS[2]}
          
          # Increment patch version
          NEW_PATCH=$((PATCH + 1))
          NEW_VERSION="$MAJOR.$MINOR.$NEW_PATCH"
          echo "New version: $NEW_VERSION"

          sed -i.bak "s/const VERSION = '$CURRENT_VERSION'/const VERSION = '$NEW_VERSION'/" app.config.ts
          rm -f app.config.ts.bak

          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV
          echo "VERSION_BUMPED=true" >> $GITHUB_ENV

      - name: üíæ Commit version bump
        if: steps.normalize_build_needed.outputs.build-needed == 'true' && env.VERSION_BUMPED == 'true'
        run: |
          git config --global user.name 'luke-h1'
          git config --global user.email 'luke-h1@users.noreply.github.com'
          
          # Check if there are actual changes to commit
          git add app.config.ts
          if git diff --staged --quiet; then
            echo "No changes to commit in app.config.ts"
            exit 0
          fi
          
          # Commit the changes
          git commit -m "chore(release): bump version to ${{ env.NEW_VERSION }} [skip ci]"
          
          # Push to main branch
          git push origin main
          
          echo "‚úÖ Successfully pushed version bump to GitHub"

      - name: üè∑Ô∏è Check if tag exists
        if: steps.normalize_build_needed.outputs.build-needed == 'true' && env.VERSION_BUMPED == 'true'
        id: check_tag
        run: |
          TAG_NAME="${{ env.NEW_VERSION }}"
          if git ls-remote --tags origin "$TAG_NAME" | grep -q "$TAG_NAME"; then
            echo "tag-exists=true" >> $GITHUB_OUTPUT
            echo "Tag $TAG_NAME already exists"
          else
            echo "tag-exists=false" >> $GITHUB_OUTPUT
            echo "Tag $TAG_NAME does not exist"
          fi
          echo "TAG_NAME=$TAG_NAME" >> $GITHUB_ENV

      - name: üè∑Ô∏è Create GitHub tag
        if: steps.normalize_build_needed.outputs.build-needed == 'true' && env.VERSION_BUMPED == 'true' && steps.check_tag.outputs.tag-exists == 'false'
        run: |
          git tag -a "${{ env.NEW_VERSION }}" -m "${{ env.NEW_VERSION }}"
          git push origin "${{ env.NEW_VERSION }}"
          echo "‚úÖ Created tag ${{ env.NEW_VERSION }}"

      - name: üì¶ Check if release exists
        if: steps.normalize_build_needed.outputs.build-needed == 'true' && env.VERSION_BUMPED == 'true'
        id: check_release
        run: |
          TAG_NAME="${{ env.NEW_VERSION }}"
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/$TAG_NAME")
          
          if [ "$RESPONSE" = "200" ]; then
            echo "release-exists=true" >> $GITHUB_OUTPUT
            echo "Release $TAG_NAME already exists"
          else
            echo "release-exists=false" >> $GITHUB_OUTPUT
            echo "Release $TAG_NAME does not exist (HTTP $RESPONSE)"
          fi

      - name: üì¶ Create GitHub release
        if: steps.normalize_build_needed.outputs.build-needed == 'true' && env.VERSION_BUMPED == 'true' && steps.check_release.outputs.release-exists == 'false'
        run: |
          TAG_NAME="${{ env.NEW_VERSION }}"
          curl -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Content-Type: application/json" \
            "https://api.github.com/repos/${{ github.repository }}/releases" \
            -d "{
              \"tag_name\": \"$TAG_NAME\",
              \"name\": \"Release $TAG_NAME\",
              \"body\": \"Production release $TAG_NAME\",
              \"target_commitish\": \"main\",
              \"draft\": false,
              \"prerelease\": false
            }"
          echo "‚úÖ Created release $TAG_NAME"

      - name: üìñ Get current version for OTA
        if: steps.normalize_build_needed.outputs.build-needed == 'false'
        id: get_ota_version
        run: |
          CURRENT_VERSION=$(sed -n "s/.*const VERSION = '\\([^']*\\)'.*/\\1/p" app.config.ts)
          echo "CURRENT_VERSION=$CURRENT_VERSION" >> $GITHUB_ENV
          echo "Current version for OTA: $CURRENT_VERSION"

      - name: üöÄ Create OTA update
        if: steps.normalize_build_needed.outputs.build-needed == 'false'
        id: ota_update
        run: |
          OUTPUT=$(bun eas update --channel production --environment production --message "release OTA" --non-interactive --clear-cache 2>&1)
          echo "$OUTPUT"
          echo "ota-output<<EOF" >> $GITHUB_OUTPUT
          echo "$OUTPUT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          UPDATE_GROUP_ID=$(echo "$OUTPUT" | grep -i "Update group ID" | awk '{print $NF}' | head -n 1)
          if [ -n "$UPDATE_GROUP_ID" ] && [ "$UPDATE_GROUP_ID" != "ID" ]; then
            echo "ota-fingerprint=$UPDATE_GROUP_ID" >> $GITHUB_OUTPUT
            echo "Extracted OTA fingerprint: $UPDATE_GROUP_ID"
          else
            UPDATE_GROUP_ID=$(echo "$OUTPUT" | grep -i "update.*id" | awk '{print $NF}' | head -n 1)
            if [ -n "$UPDATE_GROUP_ID" ] && [ "$UPDATE_GROUP_ID" != "ID" ] && [ "$UPDATE_GROUP_ID" != "id" ]; then
              echo "ota-fingerprint=$UPDATE_GROUP_ID" >> $GITHUB_OUTPUT
              echo "Extracted OTA fingerprint (fallback): $UPDATE_GROUP_ID"
            else
              echo "ota-fingerprint=unknown" >> $GITHUB_OUTPUT
              echo "Warning: Could not extract OTA fingerprint"
            fi
          fi
          
          # Check for fingerprint errors
          if echo "$OUTPUT" | grep -q "No compatible builds found for the following fingerprints:"; then
            echo "fingerprint-error=true" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è ERROR: No compatible builds found for fingerprints!"
            echo "This means the version in app.config.ts has changed but no build exists for the new fingerprint."
            echo "The workflow should have detected this and triggered a build."
            echo "Current version: ${{ env.CURRENT_VERSION }}"
            exit 1
          else
            echo "fingerprint-error=false" >> $GITHUB_OUTPUT
          fi

      - name: üè∑Ô∏è Create OTA tag
        if: steps.normalize_build_needed.outputs.build-needed == 'false'
        run: |
          git config --global user.name 'luke-h1'
          git config --global user.email 'luke-h1@users.noreply.github.com'
          
          # Create tag name in format: {VERSION}-{FINGERPRINT}
          OTA_FINGERPRINT="${{ steps.ota_update.outputs.ota-fingerprint }}"
          TAG_NAME="${{ env.CURRENT_VERSION }}-${OTA_FINGERPRINT}"
          
          # Create tag with OTA output as message
          OTA_OUTPUT="${{ steps.ota_update.outputs.ota-output }}"
          TAG_MESSAGE=$(printf "OTA Update %s\n\n%s" "${{ env.CURRENT_VERSION }}" "$OTA_OUTPUT")
          git tag -a "$TAG_NAME" -m "$TAG_MESSAGE"
          
          # Push tag
          git push origin "$TAG_NAME"
          echo "‚úÖ Created OTA tag $TAG_NAME"

      - name: üì¢ Send OTA update to Slack
        if: steps.normalize_build_needed.outputs.build-needed == 'false' && env.SLACK_WEBHOOK_URL != ''
        run: |
          if [ -z "$SLACK_WEBHOOK_URL" ]; then
            echo "SLACK_WEBHOOK_URL not set, skipping Slack notification"
            exit 0
          fi
          
          OTA_OUTPUT="${{ steps.ota_update.outputs.ota-output }}"
          
          # Escape JSON special characters: backslash, quotes, newlines, tabs
          ESCAPED_OUTPUT=$(echo "$OTA_OUTPUT" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g' | sed 's/\t/\\t/g')
          
          # Create Slack message payload
          PAYLOAD=$(cat <<JSON
          {
            "text": "üöÄ Production OTA Update Published",
            "blocks": [
              {
                "type": "header",
                "text": {
                  "type": "plain_text",
                  "text": "üöÄ Production OTA Update Published"
                }
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Version:* ${{ env.CURRENT_VERSION }}\n*Branch:* production\n\n\`\`\`${ESCAPED_OUTPUT}\`\`\`"
                }
              }
            ]
          }
          JSON
          )
          
          curl -X POST -H 'Content-type: application/json' \
            --data "$PAYLOAD" \
            "$SLACK_WEBHOOK_URL"

      - name: ‚ö†Ô∏è Send fingerprint warning to Slack
        if: steps.normalize_build_needed.outputs.build-needed == 'false' && steps.ota_update.outputs.fingerprint-error == 'true' && env.SLACK_WEBHOOK_URL != ''
        run: |
          if [ -z "$SLACK_WEBHOOK_URL" ]; then
            echo "SLACK_WEBHOOK_URL not set, skipping Slack notification"
            exit 0
          fi
          
          # Extract fingerprint information from output
          OTA_OUTPUT="${{ steps.ota_update.outputs.ota-output }}"
          
          # Extract iOS and Android fingerprints and URLs
          IOS_FINGERPRINT=$(echo "$OTA_OUTPUT" | grep -A 1 "iOS fingerprint:" | tail -n 1 | xargs)
          IOS_URL=$(echo "$OTA_OUTPUT" | grep -A 2 "iOS fingerprint:" | grep "URL" | sed 's/.*URL.*: *//' | xargs)
          ANDROID_FINGERPRINT=$(echo "$OTA_OUTPUT" | grep -A 1 "Android fingerprint:" | tail -n 1 | xargs)
          ANDROID_URL=$(echo "$OTA_OUTPUT" | grep -A 2 "Android fingerprint:" | grep "URL" | sed 's/.*URL.*: *//' | xargs)
          
          # Escape JSON special characters for URLs
          ESCAPED_IOS_URL=$(echo "$IOS_URL" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g')
          ESCAPED_ANDROID_URL=$(echo "$ANDROID_URL" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g')
          
          # Create Slack warning message payload
          PAYLOAD=$(cat <<JSON
          {
            "text": "‚ö†Ô∏è Warning: No compatible builds found for fingerprints",
            "blocks": [
              {
                "type": "header",
                "text": {
                  "type": "plain_text",
                  "text": "‚ö†Ô∏è Warning: No Compatible Builds Found"
                }
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Version:* ${{ env.CURRENT_VERSION }}\n*Branch:* production\n\n*No compatible builds found for the following fingerprints:*"
                }
              },
              {
                "type": "section",
                "fields": [
                  {
                    "type": "mrkdwn",
                    "text": "*iOS Fingerprint:*\n\`${IOS_FINGERPRINT}\`"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Android Fingerprint:*\n\`${ANDROID_FINGERPRINT}\`"
                  }
                ]
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*iOS URL:* <${ESCAPED_IOS_URL}|View fingerprint>\n*Android URL:* <${ESCAPED_ANDROID_URL}|View fingerprint>"
                }
              }
            ]
          }
          JSON
          )
          
          curl -X POST -H 'Content-type: application/json' \
            --data "$PAYLOAD" \
            "$SLACK_WEBHOOK_URL"

      - name: üèóÔ∏è Trigger build
        if: steps.normalize_build_needed.outputs.build-needed == 'true'
        run: |
          EXPO_PUBLIC_ENABLE_TREESHACKING=1 EXPO_APPLE_TEAM_ID="XJA7HDCMMY" bun eas build --profile production --platform ios --non-interactive --no-wait --local --output ./app-production.abd

      - name: Submit build
        if: steps.normalize_build_needed.outputs.build-needed == 'true'
        run: | 
          bun run eas submit -p ios --path ./app-production.abd
