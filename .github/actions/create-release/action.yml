name: 'Create GitHub Release'
description: 'Create git tag and GitHub release with changelog generated by git-cliff'

inputs:
  github_token:
    description: 'The Github token to use'
    required: true
  dry:
    description: 'Whether to run the action in a dry mode (not creating release, just printing logs)'
    required: false
    default: 'false'
  variant:
    description: 'The variant to use (production or preview)'
    required: true
    default: 'production'
  version:
    description: 'The app version'
    required: true
  tag:
    description: 'The git tag'
    required: true
  previous_tag:
    description: 'The previous git tag'
    required: false
    default: ''
  deployment_type:
    description: 'The deployment type (native or ota)'
    required: false
    default: 'native'
  create_tag:
    description: 'Whether to create a git tag'
    required: false
    default: 'true'
  create_release:
    description: 'Whether to create a GitHub release'
    required: false
    default: 'true'
  ios_fingerprint:
    description: 'iOS fingerprint (for OTA releases)'
    required: false
    default: ''
  android_fingerprint:
    description: 'Android fingerprint (for OTA releases)'
    required: false
    default: ''
  ios_update_id:
    description: 'iOS OTA update ID (for OTA releases)'
    required: false
    default: ''
  android_update_id:
    description: 'Android OTA update ID (for OTA releases)'
    required: false
    default: ''
  update_group_id:
    description: 'OTA update group ID (for OTA releases)'
    required: false
    default: ''

outputs:
  tag:
    description: 'The created git tag'
    value: ${{ inputs.tag }}
  previous_tag:
    description: 'The previous git tag'
    value: ${{ steps.get_previous_tag.outputs.previous_tag }}
  release_notes:
    description: 'The generated release notes'
    value: ${{ steps.generate_release_notes.outputs.release_notes }}
  changelog_updated:
    description: 'Whether the CHANGELOG.md was updated'
    value: ${{ steps.update_changelog.outputs.changed }}

runs:
  using: 'composite'
  steps:
    - name: Fixup git config
      run: git config --global --add safe.directory /github/workspace
      shell: bash

    - name: Check inputs
      shell: bash
      run: |
        echo "dry=${{ inputs.dry }}"
        echo "variant=${{ inputs.variant }}"
        echo "version=${{ inputs.version }}"
        echo "tag=${{ inputs.tag }}"
        echo "deployment_type=${{ inputs.deployment_type }}"
        if [ "${{ inputs.deployment_type }}" = "ota" ]; then
          echo "update_group_id=${{ inputs.update_group_id }}"
          echo "ios_update_id=${{ inputs.ios_update_id }}"
          echo "android_update_id=${{ inputs.android_update_id }}"
        fi

    - name: Check tag exists for early exit
      id: check_tag
      shell: bash
      run: |
        TAG="${{ inputs.tag }}"
        # Ensure we have all tags locally
        git fetch --tags origin 2>/dev/null || true

        # Check the tags
        TAG_EXISTS=$(git tag -l "${TAG}" | wc -l)
        if [ "$TAG_EXISTS" -gt 0 ]; then
          echo "Tag $TAG already exists, skipping release creation..."
          echo "tag_exists=true" >> $GITHUB_OUTPUT
        else
          echo "tag_exists=false" >> $GITHUB_OUTPUT
        fi

    - name: Get previous tag for given variant
      id: get_previous_tag
      if: steps.check_tag.outputs.tag_exists == 'false'
      shell: bash
      run: |
        FOUND_PREVIOUS_TAG=""

        # Use provided previous_tag if available
        if [ -n "${{ inputs.previous_tag }}" ]; then
          FOUND_PREVIOUS_TAG="${{ inputs.previous_tag }}"
        else
          CURRENT_TAG="${{ inputs.tag }}"

          if [ "${{ inputs.deployment_type }}" = "ota" ]; then
            # For OTA releases, find the most recent tag (either OTA or native)
            # OTA tags: ota-{updateGroupId}
            # Native tags: {version} or {version}-preview

            if [ "${{ inputs.variant }}" = "preview" ]; then
              # Find latest OTA tag for preview
              OTA_TAG=$(git tag -l "ota-*" | grep -v "^${CURRENT_TAG}$" | while read tag; do
                echo "$(git log -1 --format=%ct "$tag" 2>/dev/null || echo 0) $tag"
              done | sort -rn | sed -n '1p' | awk '{print $2}')

              # Find latest native tag for preview
              NATIVE_TAG=$(git tag -l | grep -E "preview$" | grep -vE "^ota-" | sort -V --reverse | sed -n 1p)
            else
              # Find latest OTA tag for production
              OTA_TAG=$(git tag -l "ota-*" | grep -v "^${CURRENT_TAG}$" | while read tag; do
                echo "$(git log -1 --format=%ct "$tag" 2>/dev/null || echo 0) $tag"
              done | sort -rn | sed -n '1p' | awk '{print $2}')

              # Find latest native tag for production (exclude preview tags)
              NATIVE_TAG=$(git tag -l | grep -v "preview" | grep -vE "^ota-" | sort -V --reverse | sed -n 1p)
            fi

            # Compare commit dates: use whichever is newer
            if [ -n "$NATIVE_TAG" ] && [ -n "$OTA_TAG" ]; then
              NATIVE_DATE=$(git log -1 --format=%ct "$NATIVE_TAG" 2>/dev/null || echo 0)
              OTA_DATE=$(git log -1 --format=%ct "$OTA_TAG" 2>/dev/null || echo 0)

              if [ "$NATIVE_DATE" -gt "$OTA_DATE" ]; then
                FOUND_PREVIOUS_TAG="$NATIVE_TAG"
                echo "Using native build tag (newer): ${NATIVE_TAG}"
              else
                FOUND_PREVIOUS_TAG="$OTA_TAG"
                echo "Using previous OTA tag (newer): ${OTA_TAG}"
              fi
            elif [ -n "$NATIVE_TAG" ]; then
              FOUND_PREVIOUS_TAG="$NATIVE_TAG"
              echo "Using native build tag: ${NATIVE_TAG}"
            elif [ -n "$OTA_TAG" ]; then
              FOUND_PREVIOUS_TAG="$OTA_TAG"
              echo "Using previous OTA tag: ${OTA_TAG}"
            else
              echo "No previous tag found"
            fi
          else
            # For native builds, use the original logic
            if [ "${{ inputs.variant }}" = "preview" ]; then
              FOUND_PREVIOUS_TAG=$(git tag -l | grep -E "preview$" | grep -vE "^ota-" | sort -V --reverse | sed -n 1p)
            else
              FOUND_PREVIOUS_TAG=$(git tag -l | grep -v "preview" | grep -vE "^ota-" | sort -V --reverse | sed -n 1p)
            fi
          fi
        fi

        [[ -z $(echo "$FOUND_PREVIOUS_TAG") ]] && echo "No tag found..." || echo "Tag found: ${FOUND_PREVIOUS_TAG}"

        echo "previous_tag=$FOUND_PREVIOUS_TAG" >> $GITHUB_OUTPUT

    - name: Install git-cliff
      if: steps.check_tag.outputs.tag_exists == 'false'
      shell: bash
      run: |
        curl -L --proto '=https' --tlsv1.2 -sSf https://raw.githubusercontent.com/cargo-bins/cargo-binstall/main/install-from-binstall-release.sh | bash
        ~/.cargo/bin/cargo-binstall git-cliff --no-confirm --force

    - name: Generate release notes with git-cliff
      id: generate_release_notes
      if: steps.check_tag.outputs.tag_exists == 'false'
      shell: bash
      run: |
        PREVIOUS="${{ steps.get_previous_tag.outputs.previous_tag }}"

        if [ -z "$PREVIOUS" ]; then
          RELEASE_NOTES="Initial release"
        else
          RELEASE_NOTES=$(~/.cargo/bin/git-cliff --config cliff.toml "$PREVIOUS"..HEAD --strip header 2>&1 | grep -v "^[[:space:]]*WARN\|^[[:space:]]*ERROR" || echo "")

          # Fallback to simple git log if git-cliff fails or returns empty
          if [ -z "$RELEASE_NOTES" ] || echo "$RELEASE_NOTES" | grep -q "panicked"; then
            echo "git-cliff failed or returned empty, falling back to git log"
            RELEASE_NOTES=$(git log --pretty=format:"- %s (%an)" "$PREVIOUS"..HEAD)
          fi
        fi

        # Use heredoc syntax for multiline/special character output
        {
          echo "release_notes<<EOF"
          echo "$RELEASE_NOTES"
          echo "EOF"
        } >> $GITHUB_OUTPUT

    - name: Update CHANGELOG.md
      id: update_changelog
      if: ${{ inputs.dry == 'false' && steps.check_tag.outputs.tag_exists == 'false' }}
      shell: bash
      run: |
        # Generate the full changelog
        ~/.cargo/bin/git-cliff --config cliff.toml -o CHANGELOG.md

        # Check if changelog has changed
        if git diff --quiet CHANGELOG.md 2>/dev/null; then
          echo "CHANGELOG.md has not changed"
          echo "changed=false" >> $GITHUB_OUTPUT
        else
          echo "CHANGELOG.md has changed, committing..."
          echo "changed=true" >> $GITHUB_OUTPUT

          # Configure git for commit
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Commit and push the changelog
          git add CHANGELOG.md
          git commit -m "chore(changelog): update CHANGELOG.md for ${{ inputs.tag }}"
          git push origin HEAD
          echo "CHANGELOG.md committed and pushed"
        fi

    - name: Get variant-specific app info
      id: get_app_info
      if: steps.check_tag.outputs.tag_exists == 'false'
      shell: bash
      run: |
        if [ "${{ inputs.variant }}" = "preview" ]; then
          VARIANT_TYPE="Preview"
        else
          VARIANT_TYPE="Production"
        fi

        DEPLOYMENT_TYPE="${{ inputs.deployment_type }}"
        if [ "$DEPLOYMENT_TYPE" = "ota" ]; then
          DEPLOYMENT_LABEL="OTA Update"
        else
          DEPLOYMENT_LABEL="Native Build"
        fi

        echo "variant_type=$VARIANT_TYPE" >> $GITHUB_OUTPUT
        echo "deployment_label=$DEPLOYMENT_LABEL" >> $GITHUB_OUTPUT

    - name: Create a new tag
      id: tag
      if: ${{ inputs.dry == 'false' && steps.check_tag.outputs.tag_exists == 'false' && inputs.create_tag != 'false' }}
      uses: anothrNick/github-tag-action@1.67.0
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
        CUSTOM_TAG: ${{ inputs.tag }}
        TAG_MESSAGE: |
          ${{ steps.get_app_info.outputs.variant_type }} ${{ steps.get_app_info.outputs.deployment_label }}: ${{ inputs.tag }}

          ${{ github.event.head_commit.message }}

    - name: Build release body
      id: build_release_body
      if: ${{ inputs.dry == 'false' && steps.check_tag.outputs.tag_exists == 'false' && inputs.create_release != 'false' }}
      shell: bash
      run: |
        BODY="## ${{ steps.get_app_info.outputs.variant_type }} ${{ steps.get_app_info.outputs.deployment_label }}: ${{ inputs.tag }}

        **Deployment Type:** ${{ steps.get_app_info.outputs.deployment_label }}
        **App Version:** \`${{ inputs.version }}\`
        **Previous tag:** ${{ steps.get_previous_tag.outputs.previous_tag || 'N/A (initial release)' }}"

        # Add OTA-specific info
        if [ "${{ inputs.deployment_type }}" = "ota" ]; then
          # Add Update Group ID (primary identifier for OTA updates)
          if [ -n "${{ inputs.update_group_id }}" ]; then
            BODY="${BODY}

        ### OTA Update Info
        **Update Group ID:** \`${{ inputs.update_group_id }}\`"
          fi

          # Add platform-specific update IDs
          if [ -n "${{ inputs.ios_update_id }}" ]; then
            BODY="${BODY}
        **iOS Update ID:** \`${{ inputs.ios_update_id }}\`"
          fi
          if [ -n "${{ inputs.android_update_id }}" ]; then
            BODY="${BODY}
        **Android Update ID:** \`${{ inputs.android_update_id }}\`"
          fi

          # Add fingerprints
          if [ -n "${{ inputs.ios_fingerprint }}" ] || [ -n "${{ inputs.android_fingerprint }}" ]; then
            BODY="${BODY}

        ### Fingerprints"
            if [ -n "${{ inputs.ios_fingerprint }}" ]; then
              BODY="${BODY}
        **iOS:** \`${{ inputs.ios_fingerprint }}\`"
            fi
            if [ -n "${{ inputs.android_fingerprint }}" ]; then
              BODY="${BODY}
        **Android:** \`${{ inputs.android_fingerprint }}\`"
            fi
          fi
        fi

        BODY="${BODY}

        ---

        ${{ steps.generate_release_notes.outputs.release_notes }}"

        # Use heredoc for multiline output
        {
          echo "body<<EOF"
          echo "$BODY"
          echo "EOF"
        } >> $GITHUB_OUTPUT

    - name: Create a new release
      if: ${{ inputs.dry == 'false' && steps.check_tag.outputs.tag_exists == 'false' && inputs.create_release != 'false' }}
      uses: ncipollo/release-action@v1
      with:
        token: ${{ inputs.github_token }}
        tag: ${{ inputs.tag }}
        draft: false
        makeLatest: ${{ inputs.variant == 'production' }}
        generateReleaseNotes: false
        body: ${{ steps.build_release_body.outputs.body }}
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}

    - name: Dry run output
      if: ${{ inputs.dry == 'true' && steps.check_tag.outputs.tag_exists == 'false' }}
      shell: bash
      run: |
        echo "========= DRY MODE =========="
        echo "Would create GitHub release:"
        echo "Tag: ${{ inputs.tag }}"
        echo "App Version: ${{ inputs.version }}"
        echo "Variant: ${{ inputs.variant }}"
        echo "Deployment Type: ${{ steps.get_app_info.outputs.deployment_label }}"
        echo "Previous tag: ${{ steps.get_previous_tag.outputs.previous_tag }}"
        if [ "${{ inputs.deployment_type }}" = "ota" ]; then
          echo ""
          echo "=== OTA Update Info ==="
          echo "Update Group ID: ${{ inputs.update_group_id }}"
          echo "iOS Update ID: ${{ inputs.ios_update_id }}"
          echo "Android Update ID: ${{ inputs.android_update_id }}"
          echo "iOS Fingerprint: ${{ inputs.ios_fingerprint }}"
          echo "Android Fingerprint: ${{ inputs.android_fingerprint }}"
        fi
        echo ""
        echo "=== CHANGELOG.md ==="
        echo "Would generate and commit CHANGELOG.md if changed"
        echo ""
        echo "=== Generated Changelog ==="
        echo "${{ steps.generate_release_notes.outputs.release_notes }}"
        echo "============================="
