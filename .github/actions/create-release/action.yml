name: 'Create GitHub Release'
description: 'Create git tag and GitHub release with changelog generated by git-cliff'

inputs:
  github_token:
    description: 'The Github token to use'
    required: true
  dry:
    description: 'Whether to run the action in a dry mode (not creating release, just printing logs)'
    required: false
    default: 'false'
  variant:
    description: 'The variant to use (production or preview)'
    required: true
    default: 'production'
  version:
    description: 'The app version'
    required: true
  tag:
    description: 'The git tag'
    required: true
  previous_tag:
    description: 'The previous git tag'
    required: false
    default: ''
  deployment_type:
    description: 'The deployment type (native or ota)'
    required: false
    default: 'native'
  create_tag:
    description: 'Whether to create a git tag'
    required: false
    default: 'true'
  create_release:
    description: 'Whether to create a GitHub release'
    required: false
    default: 'true'
  ios_fingerprint:
    description: 'iOS fingerprint (for OTA releases)'
    required: false
    default: ''
  android_fingerprint:
    description: 'Android fingerprint (for OTA releases)'
    required: false
    default: ''
  ios_update_id:
    description: 'iOS OTA update ID (for OTA releases)'
    required: false
    default: ''
  android_update_id:
    description: 'Android OTA update ID (for OTA releases)'
    required: false
    default: ''
  update_group_id:
    description: 'OTA update group ID (for OTA releases)'
    required: false
    default: ''
  runtime_version:
    description: 'Target runtime version for OTA updates (x.x.x format)'
    required: false
    default: ''

outputs:
  tag:
    description: 'The created git tag'
    value: ${{ inputs.tag }}
  previous_tag:
    description: 'The previous git tag'
    value: ${{ steps.get_previous_tag.outputs.previous_tag }}
  release_notes:
    description: 'The generated release notes'
    value: ${{ steps.generate_release_notes.outputs.release_notes }}
  changelog_updated:
    description: 'Whether the CHANGELOG.md was updated'
    value: ${{ steps.update_changelog.outputs.changed }}

runs:
  using: 'composite'
  steps:
    - name: Fixup git config
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
      run: |
        git config --global --add safe.directory /github/workspace
        # Configure git to use token for authentication
        git config --global url."https://x-access-token:${GITHUB_TOKEN}@github.com/".insteadOf "https://github.com/"

    - name: Check inputs
      shell: bash
      run: |
        echo "dry=${{ inputs.dry }}"
        echo "variant=${{ inputs.variant }}"
        echo "version=${{ inputs.version }}"
        echo "tag=${{ inputs.tag }}"
        echo "deployment_type=${{ inputs.deployment_type }}"
        if [ "${{ inputs.deployment_type }}" = "ota" ]; then
          echo "update_group_id=${{ inputs.update_group_id }}"
          echo "ios_update_id=${{ inputs.ios_update_id }}"
          echo "android_update_id=${{ inputs.android_update_id }}"
          if [ -n "${{ inputs.runtime_version }}" ]; then
            echo "runtime_version=${{ inputs.runtime_version }}"
          fi
        fi

    - name: Check tag exists for early exit
      id: check_tag
      shell: bash
      run: |
        TAG="${{ inputs.tag }}"
        # Ensure we have all tags locally
        git fetch --tags origin 2>/dev/null || true

        # Check the tags
        TAG_EXISTS=$(git tag -l "${TAG}" | wc -l)
        if [ "$TAG_EXISTS" -gt 0 ]; then
          echo "Tag $TAG already exists, skipping release creation..."
          echo "tag_exists=true" >> $GITHUB_OUTPUT
        else
          echo "tag_exists=false" >> $GITHUB_OUTPUT
        fi

    - name: Get previous tag for given variant
      id: get_previous_tag
      if: steps.check_tag.outputs.tag_exists == 'false'
      shell: bash
      run: |
        set +e  # Disable exit on error for this script - we handle errors manually
        FOUND_PREVIOUS_TAG=""

        # Use provided previous_tag if available
        if [ -n "${{ inputs.previous_tag }}" ]; then
          FOUND_PREVIOUS_TAG="${{ inputs.previous_tag }}"
        else
          CURRENT_TAG="${{ inputs.tag }}"

          if [ "${{ inputs.deployment_type }}" = "ota" ]; then
            # For OTA releases, find the most recent tag (either OTA or native)
            # OTA tags: ota-{updateGroupId}
            # Native tags: {version} or {version}-preview

            if [ "${{ inputs.variant }}" = "preview" ]; then
              # Find latest OTA tag for preview
              OTA_TAGS=$(git tag -l "ota-*" 2>/dev/null | grep -v "^${CURRENT_TAG}$" || true)
              if [ -n "$OTA_TAGS" ]; then
                OTA_TAG=$(echo "$OTA_TAGS" | while read tag; do
                  echo "$(git log -1 --format=%ct "$tag" 2>/dev/null || echo 0) $tag"
                done | sort -rn | head -1 | awk '{print $2}')
              else
                OTA_TAG=""
              fi

              # Find latest native tag for preview
              NATIVE_TAG=$(git tag -l 2>/dev/null | grep -E "preview$" | grep -vE "^ota-" | sort -V --reverse | head -1 || true)
            else
              # Find latest OTA tag for production
              OTA_TAGS=$(git tag -l "ota-*" 2>/dev/null | grep -v "^${CURRENT_TAG}$" || true)
              if [ -n "$OTA_TAGS" ]; then
                OTA_TAG=$(echo "$OTA_TAGS" | while read tag; do
                  echo "$(git log -1 --format=%ct "$tag" 2>/dev/null || echo 0) $tag"
                done | sort -rn | head -1 | awk '{print $2}')
              else
                OTA_TAG=""
              fi

              # Find latest native tag for production (exclude preview tags)
              NATIVE_TAG=$(git tag -l 2>/dev/null | grep -v "preview" | grep -vE "^ota-" | sort -V --reverse | head -1 || true)
            fi

            # Compare commit dates: use whichever is newer
            if [ -n "$NATIVE_TAG" ] && [ -n "$OTA_TAG" ]; then
              NATIVE_DATE=$(git log -1 --format=%ct "$NATIVE_TAG" 2>/dev/null || echo 0)
              OTA_DATE=$(git log -1 --format=%ct "$OTA_TAG" 2>/dev/null || echo 0)

              if [ "$NATIVE_DATE" -gt "$OTA_DATE" ]; then
                FOUND_PREVIOUS_TAG="$NATIVE_TAG"
                echo "Using native build tag (newer): ${NATIVE_TAG}"
              else
                FOUND_PREVIOUS_TAG="$OTA_TAG"
                echo "Using previous OTA tag (newer): ${OTA_TAG}"
              fi
            elif [ -n "$NATIVE_TAG" ]; then
              FOUND_PREVIOUS_TAG="$NATIVE_TAG"
              echo "Using native build tag: ${NATIVE_TAG}"
            elif [ -n "$OTA_TAG" ]; then
              FOUND_PREVIOUS_TAG="$OTA_TAG"
              echo "Using previous OTA tag: ${OTA_TAG}"
            else
              echo "No previous tag found"
            fi
          else
            # For native builds, use the original logic
            if [ "${{ inputs.variant }}" = "preview" ]; then
              FOUND_PREVIOUS_TAG=$(git tag -l 2>/dev/null | grep -E "preview$" | grep -vE "^ota-" | sort -V --reverse | head -1 || true)
            else
              FOUND_PREVIOUS_TAG=$(git tag -l 2>/dev/null | grep -v "preview" | grep -vE "^ota-" | sort -V --reverse | head -1 || true)
            fi
          fi
        fi

        if [ -z "$FOUND_PREVIOUS_TAG" ]; then
          echo "No tag found..."
        else
          echo "Tag found: ${FOUND_PREVIOUS_TAG}"
        fi

        echo "previous_tag=$FOUND_PREVIOUS_TAG" >> $GITHUB_OUTPUT

    - name: Install git-cliff
      if: steps.check_tag.outputs.tag_exists == 'false'
      shell: bash
      run: |
        curl -L --proto '=https' --tlsv1.2 -sSf https://raw.githubusercontent.com/cargo-bins/cargo-binstall/main/install-from-binstall-release.sh | bash
        ~/.cargo/bin/cargo-binstall git-cliff --no-confirm --force

    - name: Generate release notes with git-cliff
      id: generate_release_notes
      if: steps.check_tag.outputs.tag_exists == 'false'
      shell: bash
      run: |
        PREVIOUS="${{ steps.get_previous_tag.outputs.previous_tag }}"
        TAG="${{ inputs.tag }}"

        if [ -z "$PREVIOUS" ]; then
          RELEASE_NOTES="Initial release"
        else
          # Generate release notes for only unreleased commits since the previous tag
          # --tag sets the version name, --unreleased only includes commits not in any tag
          # --strip all removes headers/footers, leaving just the grouped commits
          RAW_NOTES=$(~/.cargo/bin/git-cliff --config cliff.toml "$PREVIOUS"..HEAD --tag "$TAG" --unreleased --strip all 2>&1 | grep -v "^[[:space:]]*WARN\|^[[:space:]]*ERROR" || echo "")

          # Check if we got meaningful content (more than just the header)
          # Strip the header line and check if there's content
          CONTENT_ONLY=$(echo "$RAW_NOTES" | tail -n +2 | sed '/^[[:space:]]*$/d')
          
          if [ -z "$CONTENT_ONLY" ]; then
            # No unreleased changes found
            COMMIT_COUNT=$(git rev-list --count "$PREVIOUS"..HEAD 2>/dev/null || echo "0")
            if [ "$COMMIT_COUNT" = "0" ]; then
              RELEASE_NOTES="No changes since previous release."
            else
              # There are commits but they're all already tagged - use git log as fallback
              echo "No unreleased commits found, using git log for recent commits"
              GIT_LOG=$(git log --pretty=format:"- %s" "$PREVIOUS"..HEAD | head -20)
              RELEASE_NOTES="### Changes"$'\n\n'"${GIT_LOG}"
            fi
          else
            RELEASE_NOTES="$RAW_NOTES"
          fi

          # Check for git-cliff errors
          if echo "$RELEASE_NOTES" | grep -q "panicked"; then
            echo "git-cliff panicked, falling back to git log"
            GIT_LOG=$(git log --pretty=format:"- %s" "$PREVIOUS"..HEAD | head -20)
            RELEASE_NOTES="### Changes"$'\n\n'"${GIT_LOG}"
          fi
        fi

        # Use heredoc syntax for multiline/special character output
        {
          echo "release_notes<<EOF"
          echo "$RELEASE_NOTES"
          echo "EOF"
        } >> $GITHUB_OUTPUT

        echo "$RELEASE_NOTES" > .release-notes-body.md

    - name: Update CHANGELOG.md
      id: update_changelog
      if: ${{ inputs.dry == 'false' && steps.check_tag.outputs.tag_exists == 'false' }}
      shell: bash
      run: |
        # Generate the full changelog
        # Pass --tag to tell git-cliff that HEAD should be treated as this tag
        # This prevents commits from appearing as "unreleased" when they're being released
        ~/.cargo/bin/git-cliff --config cliff.toml --tag "${{ inputs.tag }}" -o CHANGELOG.md

        # Check if changelog has changed
        if git diff --quiet CHANGELOG.md 2>/dev/null; then
          echo "CHANGELOG.md has not changed"
          echo "changed=false" >> $GITHUB_OUTPUT
        else
          echo "CHANGELOG.md has changed, committing directly to main..."
          echo "changed=true" >> $GITHUB_OUTPUT

          # Configure git for commit (use the actor who triggered the workflow)
          git config user.name "${{ github.actor }}"
          git config user.email "${{ github.actor_id }}+${{ github.actor }}@users.noreply.github.com"

          # Commit and push directly to main
          git add CHANGELOG.md
          git commit -m "chore(changelog): update CHANGELOG.md for ${{ inputs.tag }}"
          git push origin HEAD:main

          echo "CHANGELOG.md committed and pushed to main"
        fi

    - name: Get variant-specific app info
      id: get_app_info
      if: steps.check_tag.outputs.tag_exists == 'false'
      shell: bash
      run: |
        if [ "${{ inputs.variant }}" = "preview" ]; then
          VARIANT_TYPE="Preview"
        else
          VARIANT_TYPE="Production"
        fi

        DEPLOYMENT_TYPE="${{ inputs.deployment_type }}"
        if [ "$DEPLOYMENT_TYPE" = "ota" ]; then
          DEPLOYMENT_LABEL="OTA Update"
        else
          DEPLOYMENT_LABEL="Native Build"
        fi

        echo "variant_type=$VARIANT_TYPE" >> $GITHUB_OUTPUT
        echo "deployment_label=$DEPLOYMENT_LABEL" >> $GITHUB_OUTPUT

    - name: Create a new tag
      id: tag
      if: ${{ inputs.dry == 'false' && steps.check_tag.outputs.tag_exists == 'false' && inputs.create_tag != 'false' }}
      uses: anothrNick/github-tag-action@1.67.0
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
        CUSTOM_TAG: ${{ inputs.tag }}
        TAG_MESSAGE: |
          ${{ steps.get_app_info.outputs.variant_type }} ${{ steps.get_app_info.outputs.deployment_label }}: ${{ inputs.tag }}

          ${{ github.event.head_commit.message }}

    - name: Build release body
      id: build_release_body
      if: ${{ inputs.dry == 'false' && steps.check_tag.outputs.tag_exists == 'false' && inputs.create_release != 'false' }}
      shell: bash
      run: |
        BODY="## ${{ steps.get_app_info.outputs.variant_type }} ${{ steps.get_app_info.outputs.deployment_label }}: ${{ inputs.tag }}

        **Deployment Type:** ${{ steps.get_app_info.outputs.deployment_label }}
        **App Version:** \`${{ inputs.version }}\`
        **Previous tag:** ${{ steps.get_previous_tag.outputs.previous_tag || 'N/A (initial release)' }}"

        # Add OTA-specific info
        if [ "${{ inputs.deployment_type }}" = "ota" ]; then
          # Add Update Group ID (primary identifier for OTA updates)
          if [ -n "${{ inputs.update_group_id }}" ]; then
            BODY="${BODY}

        ### OTA Update Info
        **Update Group ID:** \`${{ inputs.update_group_id }}\`"
          fi

          # Add target runtime version if specified
          if [ -n "${{ inputs.runtime_version }}" ]; then
            BODY="${BODY}
        **Target Runtime Version:** \`${{ inputs.runtime_version }}\`"
          fi

          # Add platform-specific update IDs
          if [ -n "${{ inputs.ios_update_id }}" ]; then
            BODY="${BODY}
        **iOS Update ID:** \`${{ inputs.ios_update_id }}\`"
          fi
          if [ -n "${{ inputs.android_update_id }}" ]; then
            BODY="${BODY}
        **Android Update ID:** \`${{ inputs.android_update_id }}\`"
          fi

          # Add fingerprints
          if [ -n "${{ inputs.ios_fingerprint }}" ] || [ -n "${{ inputs.android_fingerprint }}" ]; then
            BODY="${BODY}

        ### Fingerprints"
            if [ -n "${{ inputs.ios_fingerprint }}" ]; then
              BODY="${BODY}
        **iOS:** \`${{ inputs.ios_fingerprint }}\`"
            fi
            if [ -n "${{ inputs.android_fingerprint }}" ]; then
              BODY="${BODY}
        **Android:** \`${{ inputs.android_fingerprint }}\`"
            fi
          fi
        fi

        # Append only this release's notes (from generate_release_notes), not full CHANGELOG
        if [ -f .release-notes-body.md ]; then
          BODY="${BODY}

        ---

        $(cat .release-notes-body.md)"
        fi

        # Use heredoc for multiline output
        {
          echo "body<<EOF"
          echo "$BODY"
          echo "EOF"
        } >> $GITHUB_OUTPUT

    - name: Create a new release
      if: ${{ inputs.dry == 'false' && steps.check_tag.outputs.tag_exists == 'false' && inputs.create_release != 'false' }}
      uses: ncipollo/release-action@v1
      with:
        token: ${{ inputs.github_token }}
        tag: ${{ inputs.tag }}
        draft: false
        makeLatest: ${{ inputs.variant == 'production' }}
        generateReleaseNotes: false
        body: ${{ steps.build_release_body.outputs.body }}
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}

    - name: Dry run output
      if: ${{ inputs.dry == 'true' && steps.check_tag.outputs.tag_exists == 'false' }}
      shell: bash
      run: |
        echo "========= DRY MODE =========="
        echo "Would create GitHub release:"
        echo "Tag: ${{ inputs.tag }}"
        echo "App Version: ${{ inputs.version }}"
        echo "Variant: ${{ inputs.variant }}"
        echo "Deployment Type: ${{ steps.get_app_info.outputs.deployment_label }}"
        echo "Previous tag: ${{ steps.get_previous_tag.outputs.previous_tag }}"
        if [ "${{ inputs.deployment_type }}" = "ota" ]; then
          echo ""
          echo "=== OTA Update Info ==="
          echo "Update Group ID: ${{ inputs.update_group_id }}"
          echo "iOS Update ID: ${{ inputs.ios_update_id }}"
          echo "Android Update ID: ${{ inputs.android_update_id }}"
          echo "iOS Fingerprint: ${{ inputs.ios_fingerprint }}"
          echo "Android Fingerprint: ${{ inputs.android_fingerprint }}"
          if [ -n "${{ inputs.runtime_version }}" ]; then
            echo "Target Runtime Version: ${{ inputs.runtime_version }}"
          fi
        fi
        echo ""
        echo "=== CHANGELOG.md ==="
        echo "Would generate and commit CHANGELOG.md if changed"
        echo ""
        echo "=== Generated Changelog ==="
        echo "${{ steps.generate_release_notes.outputs.release_notes }}"
        echo "============================="
